package idlab.obelisk.definitions.catalog

import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonInclude
import com.fasterxml.jackson.annotation.JsonProperty
import idlab.obelisk.annotations.api.OblxType
import idlab.obelisk.definitions.*
import idlab.obelisk.definitions.data.EventsQuery
import idlab.obelisk.storage.codegen.StorageBase
import io.reactivex.Maybe
import io.reactivex.Single

interface MetaStore : StorageBase {

    fun getRolesForUser(userId: String, datasetId: String): Maybe<List<Role>>

    fun getRolesForTeam(teamId: String, datasetId: String): Maybe<List<Role>>

    fun getDefaultUsagePlan(): Single<UsagePlan>

    fun getUsagePlanOrDefault(planId: String?): Single<UsagePlan> {
        return (planId?.let { getUsagePlan(it) } ?: Maybe.empty())
            .switchIfEmpty(getDefaultUsagePlan())
    }

    fun getDefaultUsageLimit(): Single<UsageLimit>

    fun getUsageLimitOrDefault(usageLimitsId: String?): Single<UsageLimit> {
        return (usageLimitsId?.let { getUsageLimit(it) } ?: Maybe.empty())
            .switchIfEmpty(getDefaultUsageLimit())
    }

    fun getAggregatedUsageLimits(user: User, client: Client? = null): Single<UsageLimit>

    /**
     * Get an aggregated view of the grants for a user. This will return a map of datasetIds to single Grants.
     *
     * @param userId ID referencing the User to calculate the aggregated grants for.
     * @param datasetId (Optional) When specified, limit grant calculation to the Dataset referenced by this ID.
     */
    fun getAggregatedGrantsForUser(userId: String, datasetId: String? = null): Single<Map<String, Grant>>

    /**
     * Get the aggregated DatasetMemberships for a user. This will return a map of datasetIds to an aggregated DatasetMembership instance.
     *
     * @param userId ID referencing the User to calculate the aggregated grants for.
     * @param datasetId (Optional) When specified, limit grant calculation to the Dataset referenced by this ID.
     */
    fun getAggregatedDatasetMembershipsForUser(
        userId: String,
        datasetId: String? = null
    ): Single<Map<String, DatasetMembership>>

    fun getAggregatedGrantsForTeam(teamId: String, datasetId: String? = null): Single<Map<String, Grant>>
}

interface ProducerType

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
@OblxType(uniqueFields = ["email"])
data class User @JvmOverloads constructor(
    @JsonProperty("_id")
    val id: String? = null, // unique id, generated by IdentityStore
    val email: String, // unique email
    val firstName: String? = null,
    val lastName: String? = null,
    val platformManager: Boolean = false,
    val teamMemberships: List<TeamMembership> = listOf(),
    val datasetMemberships: List<DatasetMembership> = listOf(),
    val usageLimitId: String? = null,
    // When set to true, the User will not be listed as an origin for a Dataset (this occurs when the user posted data to the Dataset personally)
    val hideOrigin: Boolean = false,
    // When this field is set, this address will be used for email notifications instead of the address specified by the field email.
    val notificationAddress: String? = null
) : ProducerType

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
@OblxType(uniqueFields = ["name"])
data class Team(
    @JsonProperty("_id")
    val id: String? = null,
    val name: String,
    val description: String? = null,
    val usagePlanId: String? = null,
    val datasetMemberships: List<DatasetMembership> = listOf()
)

@OblxType(rootType = false)
data class TeamMembership(
    val teamId: String,
    val manager: Boolean = false
)

@OblxType(rootType = false)
data class DatasetMembership(val datasetId: String, val assignedRoleIds: Set<String> = setOf())

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
@OblxType(uniqueFields = ["userId, name"])
data class Client @JvmOverloads constructor(
    @JsonProperty("_id")
    val id: String? = null,
    val userId: String,
    val teamId: String? = null,
    val name: String,
    val confidential: Boolean = false,
    val onBehalfOfUser: Boolean = true,
    val properties: Map<String, Any> = mapOf(),
    val secretHash: String? = null,
    val restrictions: List<ClientRestriction> = listOf(), // E.g. by default a client inherits all of the user permissions, use this to restrict which operations the client can perform.
    val scope: Set<Permission> = setOf(), // E.g. use to restrict Web application to only perform READ operations on behalf of the user
    val redirectURIs: List<String> = listOf(),
    // When set to true, the Client will not be listed as an origin for a Dataset (this occurs when the Client was used to post data to the Dataset)
    val hideOrigin: Boolean = false
) : ProducerType // Be default, a non-confidential client is created that acts on behalf of the user (e.g. SPA)

open class ClientRestriction(val datasetId: String, val permissions: Set<Permission>) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is ClientRestriction) return false

        if (datasetId != other.datasetId) return false
        if (permissions != other.permissions) return false

        return true
    }

    override fun hashCode(): Int {
        var result = datasetId.hashCode()
        result = 31 * result + permissions.hashCode()
        return result
    }
}

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
@OblxType(uniqueFields = ["name"])
data class UsagePlan(
    @JsonProperty("_id")
    val id: String? = null,
    val name: String,
    val description: String? = null,
    val defaultPlan: Boolean = false,
    val maxUsers: Int,
    val userUsageLimitId: String? = null,
    val maxClients: Int,
    val clientUsageLimitId: String? = null
)

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
@OblxType(uniqueFields = ["name"])
data class UsageLimit(
    @JsonProperty("_id")
    val id: String? = null,
    val name: String,
    val description: String? = null,
    val defaultLimit: Boolean = false,
    val values: Map<UsageLimitId, Long> = emptyMap()
)

enum class UsageLimitId {
    maxHourlyPrimitiveEventsStored,
    maxHourlyComplexEventsStored,
    maxHourlyPrimitiveEventsStreamed,
    maxHourlyComplexEventsStreamed,
    maxHourlyPrimitiveEventQueries,
    maxHourlyComplexEventQueries,
    maxHourlyPrimitiveStatsQueries,
    maxHourlyComplexStatsQueries,
    maxDataExports,
    maxDataExportRecords,
    maxDataStreams
}

// Primary key: id
@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
@OblxType(uniqueFields = ["name"])
data class Dataset @JvmOverloads constructor(
    @JsonProperty("_id")
    val id: String? = null,
    val name: String,
    val description: String? = null,
    val properties: Map<String, Any> = mapOf(),
    // Indicates if the Dataset is visible (but not accessible) to all users
    val published: Boolean = false,
    // Indicates if the Dataset is accessible for all users
    val openData: Boolean = false,
    // A set of keywords / tags describing the Dataset
    val keywords: Set<String> = setOf(),
    // License information, e.g. the URI of a Dublin Core LicenseDocument
    val license: String? = null,
    // The email address of the person or organisation that can be contacted for more information on the Dataset
    val contactPoint: String? = null,
    // Information about the publisher for this Dataset
    val publisher: DatasetPublisher? = null,
    // If set to true, the Dataset will not be available for listing // querying // ingesting
    val locked: Boolean = false
)

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
data class DatasetPublisher(
    val name: String? = null,
    val homepage: String? = null
)

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
@OblxType(uniqueFields = ["datasetId, name"])
data class Role(
    @JsonProperty("_id")
    val id: String? = null,
    val name: String, // unique within dataset
    val description: String? = null,
    val datasetId: String, // Dataset the group is linked to
    val grant: Grant // Permissions the role grants
)

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
@OblxType(uniqueFields = ["datasetId, fqMetricId"])
data class Metric(
    @JsonProperty("_id")
    val id: String? = null,
    val name: MetricName,
    val datasetId: String,
    val properties: Map<String, Any> = mapOf(),
    val schema: Map<String, Any> = mapOf()
) {
    fun fqMetricId(): String {
        return name.getFullyQualifiedId()
    }
}

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
@OblxType(uniqueFields = ["datasetId, sourceId"])
data class Thing(
    @JsonProperty("_id")
    val id: String? = null,
    val sourceId: String,
    val datasetId: String,
    val properties: Map<String, Any> = mapOf()
)

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
@OblxType
data class AccessRequest(
    @JsonProperty("_id")
    val id: String? = null,
    val timestamp: Long = System.currentTimeMillis(),
    val userId: String,
    val teamId: String? = null,
    val datasetId: String,
    val type: Set<Permission> = setOf(),
    val message: String? = null,
    val status: AccessRequestStatus = AccessRequestStatus.PENDING
)

enum class Permission {
    MANAGE, READ, WRITE;

    companion object {
        fun all(): Set<Permission> {
            return values().toSet()
        }

        fun readAndWrite(): Set<Permission> {
            return setOf(READ, WRITE)
        }

        fun readOnly(): Set<Permission> {
            return setOf(READ)
        }
    }
}

enum class AccessRequestStatus {
    PENDING, APPROVED, DENIED
}

/**
 * Kan gebruikt worden om NGSI properties voor Subscription in op te slaan (en dus te vermijden dat we extra datastructuur en storage nodig hebben)
 *
 * Misschien moeten we ook een name veld toevoegen hier om logische naam in op te slaan (handig voor UI purposes ook)
 */
@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
@OblxType(uniqueFields = ["userId, name"])
data class DataStream(
    @JsonProperty("_id")
    val id: String? = null,
    val userId: String,
    val teamId: String? = null,
    // user specific, optional, name. no constraints here, uniqueness or otherwise.
    val name: String? = null,
    val properties: Map<String, Any> = mapOf(),
    override val dataRange: DataRange,
    val timestampPrecision: TimestampPrecision = TimestampPrecision.milliseconds,
    val fields: List<EventField> = listOf(EventField.timestamp, EventField.metric, EventField.source, EventField.value),
    override var filter: FilterExpression = SELECT_ALL,
    @Deprecated("New SSE implementation does not store streaming state in the DataStore. Use an instance of StreamingSessions instead!")
    val clientConnected: Boolean = false
) : DataRequest {

    init {
        require(fields.isNotEmpty())
    }

    fun toQuery(): EventsQuery {
        return EventsQuery(
            dataRange = dataRange,
            timestampPrecision = timestampPrecision,
            fields = fields,
            filter = filter
        )
    }
}

// Primary key: id
@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
@OblxType(uniqueFields = ["userId, name"])
data class DataExport(
    @JsonProperty("_id")
    val id: String? = null,
    // user specific, optional, name. no constraints here, uniqueness or otherwise.
    val name: String? = null,
    val userId: String,
    val teamId: String? = null,
    override val dataRange: DataRange,
    val timestampPrecision: TimestampPrecision = TimestampPrecision.milliseconds,
    // TODO should we allow an empty list of fields?
    val fields: List<EventField> = listOf(EventField.metric, EventField.source, EventField.value),
    override var filter: FilterExpression = SELECT_ALL,
    val from: Long? = null,
    val to: Long? = null,
    val limit: Int? = null,
    val requestedOn: Long = System.currentTimeMillis(),
    val status: DataExportStatus = DataExportStatus(),
    var result: DataExportResult? = null
) : DataRequest {

    init {
        require(fields.isNotEmpty())
    }

}

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
data class DataExportStatus(
    var status: ExportStatus = ExportStatus.QUEUING,
    var recordsEstimate: Long = 0,
    var recordsProcessed: Long = 0,
    var resumeCursor: String? = null
)

enum class DataExportStatusFields(private val fieldName: String) {
    STATUS("status");

    override fun toString(): String {
        return fieldName
    }
}

data class DataExportResult(
    val completedOn: Long,
    val expiresOn: Long = 0,
    val sizeInBytes: Long,
    val compressedSizeInBytes: Long
)

enum class ExportStatus {
    QUEUING, GENERATING, CANCELLED, COMPLETED, FAILED
}

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
@OblxType
data class Announcement(
    @JsonProperty("_id")
    val id: String? = null,
    val type: AnnouncementType = AnnouncementType.INFO,
    val timestamp: Long = System.currentTimeMillis(),
    val title: String,
    val content: String
)

enum class AnnouncementType {
    INFO, WARNING, DANGER
}